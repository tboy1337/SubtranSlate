import re
import execjs
import urllib.request
import urllib.parse
import urllib.error
import json
import time
import requests
import random
import sys


class TkGenerator:
    """
    Compute the "TK" of the string.
    TK is a str generated by js, and you should post the string and the corresponding TK when you translate.
    Just like the hash of a string.
    """

    def __init__(self):
        self.ctx = execjs.compile("""
        function TL(a) {
        var k = "";
        var b = 406644;
        var b1 = 3293161072;
        var jd = ".";
        var $b = "+-a^+6";
        var Zb = "+-3^+b+-f";
        for (var e = [], f = 0, g = 0; g < a.length; g++) {
            var m = a.charCodeAt(g);
            128 > m ? e[f++] = m : (2048 > m ? e[f++] = m >> 6 | 192 : (55296 == (m & 64512) && g + 1 < a.length && 56320 == (a.charCodeAt(g + 1) & 64512) ? (m = 65536 + ((m & 1023) << 10) + (a.charCodeAt(++g) & 1023),
            e[f++] = m >> 18 | 240,
            e[f++] = m >> 12 & 63 | 128) : e[f++] = m >> 12 | 224,
            e[f++] = m >> 6 & 63 | 128),
            e[f++] = m & 63 | 128)
        }
        a = b;
        for (f = 0; f < e.length; f++) a += e[f],
        a = RL(a, $b);
        a = RL(a, Zb);
        a ^= b1 || 0;
        0 > a && (a = (a & 2147483647) + 2147483648);
        a %= 1E6;
        return a.toString() + jd + (a ^ b)
    };
    function RL(a, b) {
        var t = "a";
        var Yb = "+";
        for (var c = 0; c < b.length - 2; c += 3) {
            var d = b.charAt(c + 2),
            d = d >= t ? d.charCodeAt(0) - 87 : Number(d),
            d = b.charAt(c + 1) == Yb ? a >>> d: a << d;
            a = b.charAt(c) == Yb ? a + d & 4294967295 : a ^ d
        }
        return a
    }
    """)

    def get_tk(self, text: str) -> str:
        return self.ctx.call("TL", text)


class Translator:
    def __init__(self):
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.1 Safari/605.1.15',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36'
        ]
        self.headers = {'User-Agent': random.choice(self.user_agents)}
        self.tk_gen = TkGenerator()
        self.pattern = re.compile(r'\["(.*?)(?:\\n)')
        self.max_limited = 3500
        self.debug = False

    def set_debug(self, debug=True):
        """Enable or disable debug mode for detailed error messages"""
        self.debug = debug

    def __post(self, url, text):
        if self.debug:
            print(f"Trying URL: {url}")
            
        post_data = {
            'q': text
        }
        try:
            # First try the requests library which is more reliable
            response = requests.post(url, data=post_data, headers=self.headers, timeout=10)
            if response.status_code == 200:
                return response.text
            else:
                if self.debug:
                    print(f"HTTP Error: {response.status_code}, trying fallback method")
                # Fall back to urllib if requests fails
                data = urllib.parse.urlencode(post_data).encode(encoding='utf-8')
                request = urllib.request.Request(url=url, data=data, headers=self.headers)
                response = urllib.request.urlopen(request, timeout=10)
                return response.read().decode('utf-8')
        except Exception as e:
            if self.debug:
                print(f"Translation error with URL {url}: {str(e)}")
            return None

    def __translate(self, text, src_lang, target_lang) -> str:
        # Try multiple endpoints in sequence until one works
        endpoints = [
            # Direct Google Translate API
            ("https://translate.googleapis.com/translate_a/single?client=gtx"
             f"&sl={src_lang}&tl={target_lang}&dt=t&q={urllib.parse.quote(text)}"),
            
            # Alternative Google Translate endpoint
            ("https://translate.google.com/translate_a/single?client=at"
             f"&sl={src_lang}&tl={target_lang}&dt=t&q={urllib.parse.quote(text)}"),
             
            # Classical Google translate service
            ("https://translate.google.com/translate_a/single?client=webapp"
             f"&sl={src_lang}&tl={target_lang}&dt=t&hl=en&q={urllib.parse.quote(text)}")
        ]
        
        # Try each endpoint in order
        for endpoint in endpoints:
            result = self.__post(endpoint, text)
            if result:
                try:
                    # Test if result is valid JSON
                    json.loads(result)
                    return result
                except json.JSONDecodeError:
                    if self.debug:
                        print(f"Invalid JSON response from {endpoint}")
                    continue
        
        # If all endpoints fail, return a simple message
        if self.debug:
            print("All translation endpoints failed")
        return None

    def translate_raw(self, text: str, src_lang: str, target_lang: str) -> str:
        """
        Similar with the method "translate", but this return more information.
        :param text: Origin text
        :param src_lang: source language. the ISO-639-1 language code of the input text
        :param target_lang: target language. the ISO-639-1 language code of the output text
        :return: raw respond string
        """
        return self.__translate(text, src_lang, target_lang)

    def translate(self, text: str, src_lang: str, target_lang: str) -> str:
        """
        Execute translate.
        Afrikaans	af      Albanian	sq      Amharic	am      Arabic	ar      Armenian	hy      Azerbaijani	az
        Basque	eu          Belarusian	be      Bengali	bn      Bosnian	bs      Bulgarian	bg      Catalan	ca
        Cebuano	ceb         Chinese(Simplified)	zh-CN           Chinese (Traditional)	zh-TW
        Corsican	co      Croatian	hr      Czech	cs      Danish	da      Dutch	nl          English	en
        Esperanto	eo      Estonian	et      Finnish	fi      French	fr      Frisian	fy          Galician	gl
        Georgian	ka      German	de          Greek	el      Gujarati	gu  Haitian Creole	ht  Hausa	ha
        Hawaiian	haw     Hebrew	he          Hindi	hi      Hmong	hmn     Hungarian	hu      Icelandic	is
        Igbo	ig          Indonesian	id      Irish	ga      Italian	it      Japanese	ja      Javanese	jw
        ...

        Explore more google translate supported language please visit: https://cloud.google.com/translate/docs/languages
        :param text: Origin text
        :param src_lang: source language. the ISO-639-1 language code of the input text
        :param target_lang: target language. the ISO-639-1 language code of the output text
        :return: translated text
        """
        # Debug message to track progress
        print(f"Translating text from {src_lang} to {target_lang}...")
        
        result = self.__translate(text, src_lang, target_lang)
        if not result:
            print("Translation failed. Please check your internet connection.")
            return text
            
        try:
            obj_result = json.loads(result)
            
            # Different response formats based on the endpoint
            if isinstance(obj_result, list) and len(obj_result) > 0 and isinstance(obj_result[0], list):
                # Standard format from Google Translate API
                list_sentence = [x[0] for x in obj_result[0] if x and len(x) > 0 and x[0]]
                return ''.join(list_sentence)
            elif 'sentences' in obj_result and isinstance(obj_result['sentences'], list):
                # Alternative format
                list_sentence = [x['trans'] for x in obj_result['sentences'] if 'trans' in x]
                return ''.join(list_sentence)
            else:
                if self.debug:
                    print(f"Unexpected response format: {obj_result}")
                return text
                
        except (json.JSONDecodeError, IndexError, TypeError, KeyError) as e:
            if self.debug:
                print(f"Error parsing translation result: {e}")
                print(f"Response: {result[:200]}...")  # Show part of the response
            return text

    def translate_lines(self, text_list: list, src_lang: str, target_lang: str) -> str:
        """
        Translate a text list into sentences.
        :param text_list:
        :param src_lang:
        :param target_lang:
        :return:
        """
        if not text_list:
            return ""
            
        translated = ''
        last_idx = 0
        total_length = 0
        
        print(f"Translating {len(text_list)} lines from {src_lang} to {target_lang}...")
        
        for i in range(len(text_list)):
            total_length += len(text_list[i])
            if total_length > self.max_limited:
                chunk = '\n'.join(text_list[last_idx:i])
                print(f"Translating chunk ({len(chunk)} characters)...")
                translated_chunk = self.translate(chunk, src_lang, target_lang)
                translated += translated_chunk
                translated += '\n'
                time.sleep(1.5)  # Sleep a bit longer to avoid rate limiting
                last_idx = i
                total_length = 0
                
        # Translate the last chunk
        if last_idx < len(text_list):
            chunk = '\n'.join(text_list[last_idx:])
            print(f"Translating final chunk ({len(chunk)} characters)...")
            translated_chunk = self.translate(chunk, src_lang, target_lang)
            translated += translated_chunk
            
        return translated


if __name__ == '__main__':
    # Enable debug mode for testing
    t = Translator()
    t.set_debug(True)
    
    raw_text = "The Translation API's recognition engine supports a wide variety of languages for the Phrase-Based \
    Machine Translation (PBMT) and Neural Machine Translation (NMT) models. \nThese languages are specified within a \
    recognition request using language code parameters as noted on this page. \nMost language code parameters conform \
    to ISO-639-1 identifiers, except where noted."
    
    print("Testing translation to Chinese...")
    print(t.translate(raw_text, src_lang='en', target_lang='zh-CN'))
    
    print("\nTesting translation to Japanese...")
    print(t.translate(raw_text, src_lang='en', target_lang='ja')) 